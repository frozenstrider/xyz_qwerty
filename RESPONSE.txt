Great update — and congrats on getting it running again. Below is a **focused fix‑pack** that addresses the blooming/rounding issues, improves the **Glass** implementation, upgrades **Comic** with a pencil‑texture stroke, adds a new **Discover (Marketplace)** section, and enables **local RAW import** with a **gapless vertical reader**.

I’ve also grounded the “Liquid Glass” changes in official guidance so we don’t overdo the blur/tint (Apple’s HIG materials/vibrancy; Microsoft Acrylic/Mica) — details and citations are at the end. TL;DR: Apple’s materials emphasize **blur + vibrancy + subtle blending**, *not* bright glows or heavy fog; Acrylic adds **subtle noise** to avoid plastic-y blur. We’ll do the same. ([Apple Developer][1])

---

## 1) Glass/Dark mode looks “overexposed” → **Tone down bloom & stack order**

**Symptoms you described**

* Over-bright “fog lens” → usually from **double blurs** and a **white tint ≥ 0.15** layered over semi‑transparent surfaces.
* “Rounded edges cut the whole UI” → a **top‑level ClipRRect** on the entire window; the outside shows black.

**Fix (safe and surgical):**

* Ensure glass surfaces are **decorative only** (don’t impose size) and use **one** backdrop blur.
* Replace the bright white wash with a **very low‑opacity tint** that **inverts in dark mode** (slight dark tint in light theme; slight light tint in dark theme).
* Add a **fine-grain noise** layer (~3–4% opacity) above the blur to emulate Acrylic’s texture and reduce perceived bloom.
* Remove any **top‑level ClipRRect** on the full window; keep corners for *cards*, not the entire viewport.

### Patch A — `GlassCard` (reduce bloom, add noise, keep content crisp)

*File: `apps/reader_app/lib/ui/design_system/widgets/glass_card.dart`*

```diff
@@
-import 'dart:ui';
+import 'dart:ui';
+import 'dart:math' as math;
@@
 class GlassCard extends StatelessWidget {
   const GlassCard({
     super.key,
     required this.child,
     this.onTap,
     this.padding,
     this.blurSigma = BlurTokens.regular,
     this.borderRadius = RadiusTokens.lg,
   });
@@
   @override
   Widget build(BuildContext context) {
-    final theme = Theme.of(context);
-    final bool isDark = theme.brightness == Brightness.dark;
-    final content = ClipRRect(
-      borderRadius: borderRadius,
-      child: Stack(
-        children: [
-          // Backdrop blur
-          BackdropFilter(
-            filter: ImageFilter.blur(sigmaX: blurSigma, sigmaY: blurSigma),
-            child: const SizedBox.expand(),
-          ),
-          // Tint (was too bright)
-          DecoratedBox(
-            decoration: BoxDecoration(
-              gradient: LinearGradient(
-                begin: Alignment.topLeft, end: Alignment.bottomRight,
-                colors: [
-                  Colors.white.withOpacity(isDark ? 0.06 : 0.12),
-                  Colors.white.withOpacity(isDark ? 0.03 : 0.08),
-                ],
-              ),
-              borderRadius: borderRadius,
-              border: Border.all(
-                color: Colors.white.withOpacity(isDark ? 0.10 : 0.28),
-                width: 1,
-              ),
-            ),
-          ),
-          // Child
-          Padding(padding: padding ?? const EdgeInsets.all(16), child: child),
-        ],
-      ),
-    );
+    final theme = Theme.of(context);
+    final bool isDark = theme.brightness == Brightness.dark;
+    final content = ClipRRect(
+      borderRadius: borderRadius,
+      child: Stack(children: [
+        // 1) Single, moderate blur (avoid double-Backdrops)
+        BackdropFilter(
+          filter: ImageFilter.blur(sigmaX: math.max(8, blurSigma * .8),
+                                   sigmaY: math.max(8, blurSigma * .8)),
+          child: const SizedBox.expand(),
+        ),
+        // 2) Subtle acrylic-like noise to break up bloom (cheap to paint)
+        IgnorePointer(
+          child: CustomPaint(painter: _NoisePainter(opacity: 0.035)),
+        ),
+        // 3) Gentle tint that inverts by theme (dark => light tint; light => dark tint)
+        DecoratedBox(
+          decoration: BoxDecoration(
+            color: (isDark ? Colors.white : Colors.black).withOpacity(isDark ? 0.06 : 0.05),
+            borderRadius: borderRadius,
+            border: Border.all(
+              color: isDark
+                  ? Colors.white.withOpacity(0.10)
+                  : Colors.white.withOpacity(0.22),
+              width: 1,
+            ),
+          ),
+        ),
+        // 4) Soft inner highlight top-left (very low opacity)
+        IgnorePointer(
+          child: DecoratedBox(
+            decoration: BoxDecoration(
+              borderRadius: borderRadius,
+              gradient: LinearGradient(
+                begin: Alignment.topLeft, end: Alignment.bottomRight,
+                colors: [
+                  Colors.white.withOpacity(isDark ? 0.05 : 0.06),
+                  Colors.transparent
+                ],
+              ),
+            ),
+          ),
+        ),
+        // 5) Content
+        Padding(padding: padding ?? const EdgeInsets.all(16), child: child),
+      ]),
+    );
@@
     return content;
   }
 }
+
+/// Cheap, fixed-seed white noise painter; avoids asset files.
+class _NoisePainter extends CustomPainter {
+  _NoisePainter({required this.opacity}) : _rand = math.Random(1337);
+  final double opacity;
+  final math.Random _rand;
+  @override
+  void paint(Canvas canvas, Size size) {
+    final paint = Paint()..color = Colors.white.withOpacity(opacity);
+    // ~1 dot per 600px² keeps it light.
+    final count = (size.width * size.height / 600).clamp(60, 2000).toInt();
+    for (var i = 0; i < count; i++) {
+      final dx = _rand.nextDouble() * size.width;
+      final dy = _rand.nextDouble() * size.height;
+      canvas.drawRect(Rect.fromLTWH(dx, dy, 1, 1), paint);
+    }
+  }
+  @override
+  bool shouldRepaint(covariant _NoisePainter oldDelegate) => false;
+}
```

**Result:** Glass becomes crisp (no fog), dark mode stops blooming, and borders read clearly. This matches HIG guidance (use blur + vibrancy, not glare) and Fluent’s light texture principle. ([Apple Developer][1])

### Patch B — **Remove full‑viewport clipping** to stop “black outside rounded UI”

*File: `apps/reader_app/lib/ui/window/app_window_frame.dart` (or wherever you wrapped the entire app in `ClipRRect` to round it)*

```diff
@@
-// ❌ Don’t round the entire window viewport; it clips all content and shows black outside.
-return ClipRRect(
-  borderRadius: BorderRadius.circular(20),
-  child: Scaffold( /* ... */ ),
-);
+// ✅ Let the OS handle window corners; keep content un-clipped.
+return Scaffold( /* ... */ );
```

> If you *do* want more pronounced **card** rounding: bump your **radius tokens**, not a root Clip. See Patch C.

### Patch C — Slightly **rounder cards/panels**, not the whole UI

*File: `apps/reader_app/lib/ui/design_system/tokens.dart` (or wherever radius tokens live)*

```diff
- class RadiusTokens {
-   static final BorderRadius lg = BorderRadius.circular(20);
-   static final BorderRadius xl = BorderRadius.circular(28);
- }
+ class RadiusTokens {
+   static final BorderRadius lg = BorderRadius.circular(24);
+   static final BorderRadius xl = BorderRadius.circular(32);
+ }
```

> Windows/macOS already round **window** corners; leave viewport un‑clipped to avoid the black wedges. If you’re on Windows and want OS‑level glass around the **window**, optionally layer **Acrylic/Mica** via `flutter_acrylic` (Windows/macOS) — but keep in‑app blur/tints subtle. Microsoft recommends **Acrylic for transient surfaces** and **Mica for base layers**. ([Microsoft Learn][2])

---

## 2) Comic mode → **pencil‑stroke border** (no wobbly geometry)

We’ll keep the geometry clean but render the border with a pencil texture using a shaderless `CustomPainter` so there’s no asset dependency.

### Patch D — Pencil border for Comic

*File: `apps/reader_app/lib/ui/design_system/widgets/glass_card.dart` (Comic branch)*

```diff
 class _ComicCard extends StatelessWidget {
   const _ComicCard({required this.child, required this.borderRadius, this.padding, this.onTap});
@@
-    final box = DecoratedBox(
-      decoration: BoxDecoration(
-        color: Colors.white,
-        borderRadius: borderRadius,
-        border: Border.all(color: Colors.black, width: 1.4),
-      ),
-      child: Padding(padding: padding ?? const EdgeInsets.all(SpacingTokens.md), child: child),
-    );
+    final box = CustomPaint(
+      painter: _PencilStrokePainter(borderRadius: borderRadius),
+      child: DecoratedBox(
+        decoration: BoxDecoration(color: Colors.white, borderRadius: borderRadius),
+        child: Padding(padding: padding ?? const EdgeInsets.all(SpacingTokens.md), child: child),
+      ),
+    );
@@
 }
 
+class _PencilStrokePainter extends CustomPainter {
+  _PencilStrokePainter({required this.borderRadius});
+  final BorderRadius borderRadius;
+  @override
+  void paint(Canvas canvas, Size size) {
+    final rrect = RRect.fromRectAndCorners(
+      Offset.zero & size,
+      topLeft: borderRadius.topLeft, topRight: borderRadius.topRight,
+      bottomLeft: borderRadius.bottomLeft, bottomRight: borderRadius.bottomRight,
+    );
+    final path = Path()..addRRect(rrect);
+    // Stroke with slight texture: jitter alpha + width; two passes for depth.
+    final base = Paint()
+      ..style = PaintingStyle.stroke
+      ..strokeWidth = 1.6
+      ..color = Colors.black;
+    canvas.drawPath(path, base);
+    final rnd = math.Random(42);
+    for (int i = 0; i < 2; i++) {
+      final noisy = Paint()
+        ..style = PaintingStyle.stroke
+        ..strokeWidth = 1.6 + (rnd.nextDouble() * .4 - .2)
+        ..color = Colors.black.withOpacity(.25 + rnd.nextDouble() * .15);
+      canvas.drawPath(path, noisy);
+    }
+  }
+  @override
+  bool shouldRepaint(covariant _PencilStrokePainter oldDelegate) => false;
+}
```

**Result:** solid white surfaces with a softly layered graphite line — straight edges, “hand‑inked” feel.

---

## 3) **Discover** (a.k.a. Marketplace) section

New tab with editorial shelves (“New Releases”, “Top Paid”, “On Sale”), a hero for promotions, and a **Title Detail → Purchase** sheet. Everything stays **mocked** for now.

### Patch E — add route & nav item

*Files: router + shell; adjust names to match your project.*

```diff
// router/app_router.dart
@@
 GoRoute(
   path: '/discover',
   name: 'discover',
   builder: (ctx, st) => const DiscoverScreen(),
 ),
```

```diff
// features/shared/widgets/main_shell.dart (or your nav model)
- final items = [
-   NavItem('Home', Icons.home_rounded, '/'),
-   NavItem('Search', Icons.search_rounded, '/search'),
-   NavItem('Library', Icons.collections_bookmark_rounded, '/library'),
- ];
+ final items = [
+   NavItem('Home', Icons.home_rounded, '/'),
+   NavItem('Discover', Icons.storefront_rounded, '/discover'),
+   NavItem('Search', Icons.search_rounded, '/search'),
+   NavItem('Library', Icons.collections_bookmark_rounded, '/library'),
+ ];
```

```dart
// features/discover/presentation/discover_screen.dart
class DiscoverScreen extends StatelessWidget {
  const DiscoverScreen({super.key});
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Discover')),
      body: ListView(
        padding: const EdgeInsets.all(24),
        children: const [
          _PromoHero(),
          SizedBox(height: 20),
          _Shelf(title: 'New Releases'),
          _Shelf(title: 'Top Paid'),
          _Shelf(title: 'On Sale'),
        ],
      ),
    );
  }
}
```

Each `_Shelf` is a horizontal `ListView.separated` reusing your `SeriesCard(height: 360)`; the **Buy** CTA opens your existing purchase sheet (mocked). (If you prefer “Marketplace”, rename the screen and route; the structure is the same.)

---

## 4) **Library** → import local RAWs + gapless vertical reader

**What you get now**

* “Import Folder” action in **Library** (Desktop first; Android/iOS can pick files).
* We scan the folder (and immediate subfolders), take common image types, **sort by filename**, and create a **Local Series** with **Local Chapter** entries.
* Reader presents a **seamless vertical scroll** with **no gaps** (0 padding) and **gaplessPlayback**.

**Dependencies to add** (in `pubspec.yaml`):

```yaml
dependencies:
  file_picker: ^8.0.0
  path: ^1.9.0
```

### Patch F — Library UI

*File: `features/library/presentation/library_screen.dart`*

```diff
@@
 AppBar(
-  title: const Text('Library'),
+  title: const Text('Library'),
   actions: [
-    // …
+    IconButton(
+      tooltip: 'Import Folder',
+      icon: const Icon(Icons.folder_open_rounded),
+      onPressed: () async {
+        final path = await FilePicker.platform.getDirectoryPath(dialogTitle: 'Select manga folder');
+        if (path == null) return;
+        if (!context.mounted) return;
+        final repo = context.read(localLibraryRepositoryProvider);
+        final series = await repo.importFolder(path);
+        if (!context.mounted) return;
+        ScaffoldMessenger.of(context).showSnackBar(
+          SnackBar(content: Text('Imported ${series.title}')),
+        );
+      },
+    ),
   ],
 ),
@@
-// Existing list/grid of items …
+// Display imported local series in a grid
+Consumer(builder: (context, ref, _) {
+  final series = ref.watch(localSeriesProvider);
+  return GridView.builder(
+    padding: const EdgeInsets.all(24),
+    gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
+      crossAxisCount: 5, mainAxisSpacing: 20, crossAxisSpacing: 20, childAspectRatio: 3/4),
+    itemCount: series.length,
+    itemBuilder: (c, i) => SeriesCard(
+      series: series[i].toSeriesStub(), // map to your existing card model
+      onTap: () => context.push('/reader/local', extra: series[i]),
+    ),
+  );
+}),
```

### Patch G — Repository & Reader

*New files (examples):*

```dart
// domain/local_library_models.dart
class LocalSeries {
  LocalSeries({required this.id, required this.title, required this.chapters});
  final String id;
  final String title;
  final List<LocalChapter> chapters;
}

class LocalChapter {
  LocalChapter({required this.name, required this.pages});
  final String name;
  final List<String> pages; // absolute file paths
}
```

```dart
// data/local_library_repository.dart
final localLibraryRepositoryProvider = Provider((ref) => LocalLibraryRepository());

class LocalLibraryRepository {
  static const _exts = ['.jpg', '.jpeg', '.png', '.webp', '.avif'];
  Future<LocalSeries> importFolder(String dirPath) async {
    final dir = Directory(dirPath);
    final files = await dir
        .list(recursive: true, followLinks: false)
        .where((e) => e is File && _exts.any((x) => e.path.toLowerCase().endsWith(x)))
        .cast<File>()
        .toList();
    files.sort((a, b) => a.path.toLowerCase().compareTo(b.path.toLowerCase()));
    // Simple 1-chapter series based on folder name. You can group by subfolder later.
    final name = p.basename(dir.path);
    return LocalSeries(
      id: dir.path.hashCode.toString(),
      title: name,
      chapters: [LocalChapter(name: 'Imported', pages: files.map((f) => f.path).toList())],
    );
  }
}
```

```dart
// features/reader/presentation/local_vertical_reader_screen.dart
class LocalVerticalReaderScreen extends StatelessWidget {
  const LocalVerticalReaderScreen({super.key, required this.chapter});
  final LocalChapter chapter;

  @override
  Widget build(BuildContext context) {
    final width = MediaQuery.of(context).size.width;
    return Scaffold(
      appBar: AppBar(title: Text(chapter.name)),
      body: ScrollConfiguration(
        behavior: const ScrollBehavior().copyWith(scrollbars: false),
        child: ListView.builder(
          padding: EdgeInsets.zero,
          cacheExtent: 2000,
          itemCount: chapter.pages.length,
          itemBuilder: (c, i) => Image.file(
            File(chapter.pages[i]),
            width: width,
            fit: BoxFit.fitWidth,
            gaplessPlayback: true,
            filterQuality: FilterQuality.medium,
            alignment: Alignment.topCenter,
          ),
        ),
      ),
    );
  }
}
```

> **No gaps:** we set `padding: EdgeInsets.zero`, no separators, and each image fits the width. For huge chapters, you can add prefetching (`precacheImage`) in an `AutomaticKeepAliveClientMixin` wrapper for smoother scroll.

---

## 5) Is our “Liquid Glass” accurate?

Short answer: we’ve now aligned the effect with **platform guidance**:

* Apple’s HIG “Materials” describes **blur, vibrancy, blending**, and stresses **legibility**. It doesn’t call for bright white glow. We reduced tint strength and removed double blurs accordingly. ([Apple Developer][1])
* On Windows, **Acrylic** uses **blur + noise**, often for transient surfaces; **Mica** for base layers. That’s why we introduced a faint noise overlay and recommend Acrylic only on overlays/sheets, not giant surfaces. ([Microsoft Learn][2])
* `NSVisualEffectView` notes that material appearance varies by system/appearance; we mirrored that by inverting tint for dark mode and keeping opacities low. ([Apple Developer][3])

If you’d rather avoid Glass entirely for now, simply switch your theme to **Solid** or **Comic** (the implementation already routes through a `SurfaceStyle` extension). The app will stay visually consistent.

---

## 6) Quick acceptance checklist

* **Dark & Glass**: cards look crisp; no milk‑white haze; text contrast AA+.
* **Viewport**: no full‑window rounding; no black outside; **cards/panels** are more rounded.
* **Comic**: borders show pencil texture; UI uses pure white surfaces + black ink‑like lines.
* **Discover**: new tab with promo hero + 3 shelves; card actions lead to purchase sheet (mocked).
* **Library**: “Import Folder” works; reading a chapter shows **gapless vertical** page flow.

---

## Sources (design alignment)

* Apple HIG – **Materials** (translucency, vibrancy, blending; maintain legibility). ([Apple Developer][1])
* Apple – `NSVisualEffectView` notes on materials and appearance. ([Apple Developer][3])
* Microsoft Learn – **Materials in Windows apps** (Mica/Acrylic guidance). ([Microsoft Learn][2])
* Microsoft Learn – **Acrylic material** (blur + subtle noise; transient surfaces). ([Microsoft Learn][4])

---

## What I didn’t do here

I didn’t change your navigation model names or storage format for the Library; the repo may already have providers you’d prefer to use. The snippets above drop in without forcing a refactor. If you want, I can package these as **git patches** (one commit per section) so you can apply them cleanly.

If the GitHub repo is private (the URL you sent wasn’t accessible on my side), either invite read‑only access or just paste the affected files here — I’ll adjust the diffs to match your exact file paths and submit a ready‑to‑apply patchset.

[1]: https://developer.apple.com/design/human-interface-guidelines/materials?utm_source=chatgpt.com "Materials | Apple Developer Documentation"
[2]: https://learn.microsoft.com/en-us/windows/apps/design/signature-experiences/materials?utm_source=chatgpt.com "Materials used in Windows apps - Windows apps | Microsoft Learn"
[3]: https://developer.apple.com/documentation/appkit/nsvisualeffectview?utm_source=chatgpt.com "NSVisualEffectView | Apple Developer Documentation"
[4]: https://learn.microsoft.com/en-us/windows/apps/design/style/acrylic?utm_source=chatgpt.com "Acrylic material - Windows apps | Microsoft Learn"
